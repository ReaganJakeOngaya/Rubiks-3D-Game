<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>3D Rubiks Game.</title>
</head>
<body>
    <div id="ui">
        <h1>3D Rubiks Game</h1>
        <div class="controls">
            <div class="group">
              <h3>Rotate Faces</h3>
              <button id="btnU" class="face-btn">Top (U)</button>
              <button id="btnD" class="face-btn">Bottom (D)</button>
              <button id="btnL" class="face-btn">Left (L)</button>
              <button id="btnR" class="face-btn">Right (R)</button>
              <button id="btnF" class="face-btn">Front (F)</button>
              <button id="btnB" class="face-btn">Back (B)</button>
            </div>
            <div class="group">
              <h3>Controls</h3>
              <button id="btnScramble">üîÄ Scramble</button>
              <button id="btnSolve">‚úÖ Solve</button>
              <button id="btnPlay" class="hidden">‚ñ∂Ô∏è Play</button>
              <button id="btnPause" class="hidden">‚è∏Ô∏è Pause</button>
            </div>
        </div>
        <div id="timerBox">
            ‚è± Time: <span id="timer">0.00s</span>
        </div>
        <div id="messageBox"></div>
    </div>
    <div id="instructions">
    <h2>How to Play</h2>
    <div class="instruction-content">
      <h3>Basic Controls</h3>
      <ul>
        <li><strong>Rotate the cube:</strong> Click and drag anywhere on the screen</li>
        <li><strong>Zoom in/out:</strong> Use the mouse wheel or pinch gesture</li>
      </ul>

      <h3>Face Rotations</h3>
      <ul>
        <li><strong>U:</strong> Rotates the top (Up) face clockwise</li>
        <li><strong>D:</strong> Rotates the bottom (Down) face clockwise</li>
        <li><strong>L:</strong> Rotates the left face clockwise</li>
        <li><strong>R:</strong> Rotates the right face clockwise</li>
        <li><strong>F:</strong> Rotates the front face clockwise</li>
        <li><strong>B:</strong> Rotates the back face clockwise</li>
      </ul>

      <h3>Color Guide</h3>
      <div class="color-guide">
        <div class="color-item"><span class="color-swatch white"></span> White (Right)</div>
        <div class="color-item"><span class="color-swatch yellow"></span> Yellow (Left)</div>
        <div class="color-item"><span class="color-swatch red"></span> Red (Top)</div>
        <div class="color-item"><span class="color-swatch orange"></span> Orange (Bottom)</div>
        <div class="color-item"><span class="color-swatch blue"></span> Blue (Front)</div>
        <div class="color-item"><span class="color-swatch green"></span> Green (Back)</div>
      </div>

      <h3>Tips</h3>
      <ul>
        <li>The goal is to make each face a solid color</li>
        <li>Try to solve one face first, then work on the others</li>
        <li>Use the <strong>Scramble</strong> button to shuffle the cube</li>
        <li>If you get stuck, use the <strong>Solve</strong> button to reset</li>
        <li>You can pause the game anytime using the <strong>Pause</strong> button</li>
      </ul>
    </div>
    <button id="toggleInstructions">Hide Instructions</button>
  </div>

  <canvas id="rubiksCanvas"></canvas>
  
   <!-- Main script using ES modules -->

   <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.152.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.152.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6, 6, 6);
    camera.lookAt(0, 0, 0); // Jake and Copilot

    const renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('rubiksCanvas'),
        antialias: true, 
        alpha: true 
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight); // Set the size of the renderer 
    renderer.setClearColor(0x000000, 0); // Set transparent background
//////////////////////
    renderer.shadowMap.enabled = true; // Enable shadow maps - copilot
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows - copilot
    renderer.setPixelRatio(window.devicePixelRatio); // Set pixel ratio for high DPI displays - copilot
/////////////////////

    const controls = new OrbitControls(camera, renderer.domElement); // Initialize orbit controls 
    controls.enableDamping = true; // Enable damping (inertia) for smoother controls

/////////////////////
    const light = new THREE.DirectionalLight(0xffffff, 1); // Create a directional light
    light.position.set(5, 5, 5).normalize(); // Set light position - copilot
    scene.add(light); // Add light to the scene
    light.castShadow = true; // Enable shadows for the light - copilot

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Create a directional light
    directionalLight.position.set(5, 5, 5); // Set light position - copilot
    scene.add(directionalLight); // Add light to the scene
    directionalLight.castShadow = true; // Enable shadows for the light - copilot

    const faceColors = [0xffffff, 0xffff00, 0xff0000, 0xff8800, 0x0000ff, 0x00ff00];
    const colorNames = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];

    function createMaterialArray() {
        return [
          new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7 }), // Right - white
          new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.7 }), // Left - yellow
          new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.7 }), // Top - red
          new THREE.MeshStandardMaterial({ color: 0xff8800, roughness: 0.7 }), // Bottom - orange
          new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.7 }), // Front - blue
          new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.7 })  // Back - green
        ];
    }

    const gray = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 }); // copilot

    function createCubelet( x, y, z ) {
        const materials = Array(6).fill(gray).map(m = m.clone());

        // Apply colors only to the outer faces
        if (x === 1) materials[0] = createMaterialsArray()[0];
        if (x === -1) materials[1] = createMaterialsArray()[1];
        if (y === 1) materials[2] = createMaterialsArray()[2];
        if (y === -1) materials[3] = createMaterialsArray()[3];
        if (z === 1) materials[4] = createMaterialsArray()[4];
        if (z === -1) materials[5] = createMaterialsArray()[5];

        const cubelet = new THREE.Mes(new THREE.BoxGeometry(1, 1, 1), materials);// copilot
        cubelet.position.set(x, y, z); // Set position of the cubelet 
        cubelet.userData.originalPosition = new THREE.Vector3(x, y, z);
        cubelet.userData.originalMaterials = materials.map(m => m.clone());

        return cubelet; // Return the created cubelet
    }

    const cubeGroup = new THREE.Group();
    const cubelets = [];

    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          if (x === 0 && y === 0 && z === 0) continue;
          const cubelet = createCubelet(x, y, z);
          cubeGroup.add(cubelet);
          cubelets.push(cubelet);
        }
      }
    }

    scene.add(cubeGroup);



   </script>
    
</body>
</html>