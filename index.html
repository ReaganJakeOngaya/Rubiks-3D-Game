<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rubik's Cube 3D</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="theme-toggle" id="themeToggle">
    <i class="fas fa-moon"></i>
  </div>

  <div id="ui">
    <h1><i class="fas fa-cube"></i> Rubik's Cube 3D</h1>
    <div class="controls">
      <div class="group">
        <h3><i class="fas fa-sync-alt"></i> Rotate Faces</h3>
        <div class="face-buttons">
          <button id="btnU" class="face-btn"><i class="fas fa-arrow-up"></i> Top (U)</button>
          <button id="btnD" class="face-btn"><i class="fas fa-arrow-down"></i> Bottom (D)</button>
          <button id="btnL" class="face-btn"><i class="fas fa-arrow-left"></i> Left (L)</button>
          <button id="btnR" class="face-btn"><i class="fas fa-arrow-right"></i> Right (R)</button>
          <button id="btnF" class="face-btn"><i class="fas fa-forward"></i> Front (F)</button>
          <button id="btnB" class="face-btn"><i class="fas fa-backward"></i> Back (B)</button>
        </div>
      </div>
      <div class="group">
        <h3><i class="fas fa-gamepad"></i> Game Controls</h3>
        <button id="btnScramble"><i class="fas fa-random"></i> Scramble</button>
        <button id="btnSolve"><i class="fas fa-check"></i> Solve</button>
        <button id="btnReset"><i class="fas fa-redo"></i> Reset</button>
        <button id="btnPause" class="hidden"><i class="fas fa-pause"></i> Pause</button>
      </div>
    </div>
    
    <div id="stats">
      <div class="stat-row">
        <span class="stat-label"><i class="fas fa-shoe-prints"></i> Moves:</span>
        <span id="moveCount" class="stat-value">0</span>
      </div>
      <div class="stat-row">
        <span class="stat-label"><i class="fas fa-trophy"></i> Best Time:</span>
        <span id="bestTime" class="stat-value">--:--</span>
      </div>
      <div class="stat-row">
        <span class="stat-label"><i class="fas fa-flag-checkered"></i> Games Won:</span>
        <span id="gamesWon" class="stat-value">0</span>
      </div>
    </div>
    
    <div id="timerBox"><i class="fas fa-stopwatch"></i> Time: <span id="timer">0.00s</span></div>
  </div>

  <div id="winMessage">
    <div><i class="fas fa-trophy"></i> Congratulations! <i class="fas fa-trophy"></i></div>
    <div id="winStats" style="font-size: 16px; margin-top: 10px;"></div>
  </div>

  <div id="instructions">
    <h2><i class="fas fa-book"></i> How to Play</h2>
    <div class="instruction-content">
      <h3><i class="fas fa-gamepad"></i> Basic Controls</h3>
      <ul>
        <li><strong>Rotate the cube:</strong> Click and drag to rotate the view</li>
        <li><strong>Zoom in/out:</strong> Use mouse wheel or pinch gesture</li>
        <li><strong>Face rotations:</strong> Click face buttons or use keyboard</li>
      </ul>

      <h3><i class="fas fa-keyboard"></i> Keyboard Controls</h3>
      <ul>
        <li><strong>U, D, L, R, F, B:</strong> Rotate respective faces</li>
        <li><strong>Spacebar:</strong> Pause/Resume game</li>
        <li><strong>S:</strong> Scramble cube</li>
        <li><strong>Enter:</strong> Solve cube</li>
      </ul>

      <h3><i class="fas fa-sync-alt"></i> Face Rotations</h3>
      <ul>
        <li><strong>U (Up):</strong> Rotates the top face clockwise</li>
        <li><strong>D (Down):</strong> Rotates the bottom face clockwise</li>
        <li><strong>L (Left):</strong> Rotates the left face clockwise</li>
        <li><strong>R (Right):</strong> Rotates the right face clockwise</li>
        <li><strong>F (Front):</strong> Rotates the front face clockwise</li>
        <li><strong>B (Back):</strong> Rotates the back face clockwise</li>
      </ul>

      <h3><i class="fas fa-palette"></i> Color Guide</h3>
      <div class="color-guide">
        <div class="color-item"><span class="color-swatch white"></span>White (Right)</div>
        <div class="color-item"><span class="color-swatch yellow"></span>Yellow (Left)</div>
        <div class="color-item"><span class="color-swatch red"></span>Red (Top)</div>
        <div class="color-item"><span class="color-swatch orange"></span>Orange (Bottom)</div>
        <div class="color-item"><span class="color-swatch blue"></span>Blue (Front)</div>
        <div class="color-item"><span class="color-swatch green"></span>Green (Back)</div>
      </div>

      <h3><i class="fas fa-star"></i> Game Features</h3>
      <ul>
        <li>Real-time timer and move counter</li>
        <li>Best time and statistics tracking</li>
        <li>Pause and resume functionality</li>
        <li>Automatic win detection</li>
        <li>Realistic 3D cube with smooth animations</li>
      </ul>

      <h3><i class="fas fa-lightbulb"></i> Tips</h3>
      <ul>
        <li>The goal is to make each face a solid color</li>
        <li>Start by solving one face completely</li>
        <li>Learn basic algorithms for faster solving</li>
        <li>Use the scramble button for random puzzles</li>
        <li>Track your progress with the statistics</li>
      </ul>
    </div>
    <button id="toggleInstructions"><i class="fas fa-eye-slash"></i> Hide Instructions</button>
    <div class="creator"><a href="https://github.com/ReaganJakeOngaya/">Created by @ReaganJake</a></div>
  </div>

  <canvas id="rubiksCanvas"></canvas>

  <!-- Main script using ES modules -->
  <script type="module">
     import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';

     // Theme toggle functionality
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = themeToggle.querySelector('i');

    // Check for saved theme preference or default to light
    const savedTheme = localStorage.getItem('rubiksTheme') || 'light';
    if (savedTheme === 'dark') {
      document.body.classList.add('dark-theme');
      themeIcon.classList.remove('fa-moon');
      themeIcon.classList.add('fa-sun');
    }

    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-theme');
      
    if (document.body.classList.contains('dark-theme')) {
        themeIcon.classList.remove('fa-moon');
        themeIcon.classList.add('fa-sun');
        localStorage.setItem('rubiksTheme', 'dark');
      } else {
        themeIcon.classList.remove('fa-sun');
        themeIcon.classList.add('fa-moon');
        localStorage.setItem('rubiksTheme', 'light');
      }
    });    

    // OrbitControls implementation (since CDN imports don't work reliably)
    class OrbitControls {
      constructor(object, domElement) {
        this.object = object;
        this.domElement = domElement;
        this.enabled = true;
        this.enableDamping = true;
        this.dampingFactor = 0.05;
        this.enableZoom = true;
        this.zoomSpeed = 1.0;
        this.enableRotate = true;
        this.rotateSpeed = 1.0;
        this.enablePan = false;

        this.spherical = new THREE.Spherical();
        this.sphericalDelta = new THREE.Spherical();
        this.scale = 1;
        this.panOffset = new THREE.Vector3();
        this.zoomChanged = false;

        this.rotateStart = new THREE.Vector2();
        this.rotateEnd = new THREE.Vector2();
        this.rotateDelta = new THREE.Vector2();

        this.domElement.addEventListener('contextmenu', this.onContextMenu.bind(this));
        this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
        this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
        this.domElement.addEventListener('touchstart', this.onTouchStart.bind(this));
        this.domElement.addEventListener('touchend', this.onTouchEnd.bind(this));
        this.domElement.addEventListener('touchmove', this.onTouchMove.bind(this));

        this.target = new THREE.Vector3();
        this.update();
      }

      update() {
        const offset = new THREE.Vector3();
        const quat = new THREE.Quaternion().setFromUnitVectors(this.object.up, new THREE.Vector3(0, 1, 0));
        const quatInverse = quat.clone().invert();

        offset.copy(this.object.position).sub(this.target);
        offset.applyQuaternion(quat);
        this.spherical.setFromVector3(offset);

        if (this.enableDamping) {
          this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
          this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;
        } else {
          this.spherical.theta += this.sphericalDelta.theta;
          this.spherical.phi += this.sphericalDelta.phi;
        }

        this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
        this.spherical.makeSafe();
        this.spherical.radius *= this.scale;

        offset.setFromSpherical(this.spherical);
        offset.applyQuaternion(quatInverse);
        this.object.position.copy(this.target).add(offset);
        this.object.lookAt(this.target);

        if (this.enableDamping) {
          this.sphericalDelta.theta *= (1 - this.dampingFactor);
          this.sphericalDelta.phi *= (1 - this.dampingFactor);
        } else {
          this.sphericalDelta.set(0, 0, 0);
        }

        this.scale = 1;
      }

      onMouseDown(event) {
        if (!this.enabled) return;
        event.preventDefault();
        if (event.button === 0) {
          this.rotateStart.set(event.clientX, event.clientY);
          this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
          this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
        }
      }

      onMouseMove(event) {
        if (!this.enabled) return;
        event.preventDefault();
        this.rotateEnd.set(event.clientX, event.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
        
        const element = this.domElement;
        this.sphericalDelta.theta -= 2 * Math.PI * this.rotateDelta.x / element.clientHeight;
        this.sphericalDelta.phi -= 2 * Math.PI * this.rotateDelta.y / element.clientHeight;
        
        this.rotateStart.copy(this.rotateEnd);
      }

      onMouseUp() {
        this.domElement.removeEventListener('mousemove', this.onMouseMove.bind(this));
        this.domElement.removeEventListener('mouseup', this.onMouseUp.bind(this));
      }

      onMouseWheel(event) {
        if (!this.enabled || !this.enableZoom) return;
        event.preventDefault();
        if (event.deltaY < 0) {
          this.scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (event.deltaY > 0) {
          this.scale *= Math.pow(0.95, this.zoomSpeed);
        }
      }

      onTouchStart(event) {
        if (!this.enabled) return;
        if (event.touches.length === 1) {
          this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }
      }

      onTouchMove(event) {
        if (!this.enabled) return;
        event.preventDefault();
        if (event.touches.length === 1) {
          this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
          
          const element = this.domElement;
          this.sphericalDelta.theta -= 2 * Math.PI * this.rotateDelta.x / element.clientHeight;
          this.sphericalDelta.phi -= 2 * Math.PI * this.rotateDelta.y / element.clientHeight;
          
          this.rotateStart.copy(this.rotateEnd);
        }
      }

      onTouchEnd() {
        // Touch ended
      }

      onContextMenu(event) {
        if (!this.enabled) return;
        event.preventDefault();
      }
    }

    // Scene setup with enhanced lighting
    const scene = new THREE.Scene();
    scene.background = null; // Transparent background
    
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(8, 8, 8);

    const renderer = new THREE.WebGLRenderer({
       canvas: document.getElementById('rubiksCanvas'),
       antialias: true,
       alpha: true,
       powerPreference: "high-performance"
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    // Enhanced lighting setup
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight1.position.set(10, 10, 5);
    directionalLight1.castShadow = true;
    directionalLight1.shadow.mapSize.width = 2048;
    directionalLight1.shadow.mapSize.height = 2048;
    directionalLight1.shadow.camera.near = 0.5;
    directionalLight1.shadow.camera.far = 50;
    scene.add(directionalLight1);

    const directionalLight2 = new THREE.DirectionalLight(0x8888ff, 0.8);
    directionalLight2.position.set(-5, 8, -5);
    scene.add(directionalLight2);

    const rimLight = new THREE.DirectionalLight(0xff8888, 0.5);
    rimLight.position.set(-10, -10, 10);
    scene.add(rimLight);

    // Enhanced materials with better realism
    function createMaterialsArray() {
      return [
        new THREE.MeshPhysicalMaterial({ 
          color: 0xffffff, 
          roughness: 0.1, 
          metalness: 0.1,
          clearcoat: 0.8,
          clearcoatRoughness: 0.1
        }), // Right - white
        new THREE.MeshPhysicalMaterial({ 
          color: 0xffff00, 
          roughness: 0.1, 
          metalness: 0.1,
          clearcoat: 0.8,
          clearcoatRoughness: 0.1
        }), // Left - yellow
        new THREE.MeshPhysicalMaterial({ 
          color: 0xff0000, 
          roughness: 0.1, 
          metalness: 0.1,
          clearcoat: 0.8,
          clearcoatRoughness: 0.1
        }), // Top - red
        new THREE.MeshPhysicalMaterial({ 
          color: 0xff8800, 
          roughness: 0.1, 
          metalness: 0.1,
          clearcoat: 0.8,
          clearcoatRoughness: 0.1
        }), // Bottom - orange
        new THREE.MeshPhysicalMaterial({ 
          color: 0x0066ff, 
          roughness: 0.1, 
          metalness: 0.1,
          clearcoat: 0.8,
          clearcoatRoughness: 0.1
        }), // Front - blue
        new THREE.MeshPhysicalMaterial({ 
          color: 0x00ff00, 
          roughness: 0.1, 
          metalness: 0.1,
          clearcoat: 0.8,
          clearcoatRoughness: 0.1
        })  // Back - green
      ];
    }
    
    const blackMaterial = new THREE.MeshPhysicalMaterial({ 
      color: 0x111111, 
      roughness: 0.8, 
      metalness: 0.3 
    });

    // Enhanced cubelet creation with rounded edges
    function createCubelet(x, y, z) {
      const materials = Array(6).fill(blackMaterial).map(m => m.clone());
      
      // Apply colors only to the outer faces
      if (x === 1) materials[0] = createMaterialsArray()[0];
      if (x === -1) materials[1] = createMaterialsArray()[1];
      if (y === 1) materials[2] = createMaterialsArray()[2];
      if (y === -1) materials[3] = createMaterialsArray()[3];
      if (z === 1) materials[4] = createMaterialsArray()[4];
      if (z === -1) materials[5] = createMaterialsArray()[5];

      // Create geometry with slightly rounded edges
      const geometry = new THREE.BoxGeometry(0.98, 0.98, 0.98);
      
      // Add edge geometry for more realistic look
      const edges = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
      const edgeLines = new THREE.LineSegments(edges, edgeMaterial);

      const cubelet = new THREE.Mesh(geometry, materials);
      cubelet.add(edgeLines);
      cubelet.position.set(x, y, z);
      cubelet.castShadow = true;
      cubelet.receiveShadow = true;
      cubelet.userData.originalPosition = new THREE.Vector3(x, y, z);
      cubelet.userData.originalMaterials = materials.map(m => m.clone());
      
      return cubelet;
    }

    const cubeGroup = new THREE.Group();
    const cubelets = [];

    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          if (x === 0 && y === 0 && z === 0) continue;
          const cubelet = createCubelet(x, y, z);
          cubeGroup.add(cubelet);
          cubelets.push(cubelet);
        }
      }
    }

    scene.add(cubeGroup);

    // Game state variables
    let isRotating = false;
    let isPaused = false;
    let gameStarted = false;
    let moveCount = 0;
    let startTime = null;
    let timerInterval = null;
    let elapsedTime = 0;
    let bestTime = localStorage.getItem('rubiksBestTime') || null;
    let gamesWon = parseInt(localStorage.getItem('rubiksGamesWon') || '0');

    // Update UI with stored stats
    document.getElementById('bestTime').textContent = bestTime ? `${(parseFloat(bestTime) / 1000).toFixed(2)}s` : '--:--';
    document.getElementById('gamesWon').textContent = gamesWon;

    const faceAxis = { U: 'y', D: 'y', L: 'x', R: 'x', F: 'z', B: 'z' };
    const faceDirection = { U: 1, D: -1, L: -1, R: 1, F: 1, B: -1 };

    function getFaceLayer(face) {
      const tolerance = 0.2;
      switch (face) {
        case 'U': return cubeGroup.children.filter(c => Math.abs(c.position.y - 1) < tolerance);
        case 'D': return cubeGroup.children.filter(c => Math.abs(c.position.y + 1) < tolerance);
        case 'L': return cubeGroup.children.filter(c => Math.abs(c.position.x + 1) < tolerance);
        case 'R': return cubeGroup.children.filter(c => Math.abs(c.position.x - 1) < tolerance);
        case 'F': return cubeGroup.children.filter(c => Math.abs(c.position.z - 1) < tolerance);
        case 'B': return cubeGroup.children.filter(c => Math.abs(c.position.z + 1) < tolerance);
        default: return [];
      }
    }

    // Enhanced rotation with smooth animations
    function rotateFace(face) {
      if (isRotating || isPaused) return;
      
      if (!gameStarted) {
        setGameState(true);
        startTimer();
      }
      
      // Increment move counter
      moveCount++;
      updateMoveCounter();
      
      isRotating = true;
      
      const layer = getFaceLayer(face);
      const axis = faceAxis[face];
      const direction = faceDirection[face];
      const angle = Math.PI / 2 * direction;

      const group = new THREE.Group();
      scene.add(group);
      
      const quaternion = new THREE.Quaternion();
      const rotationAxis = new THREE.Vector3();
      
      if (axis === 'x') rotationAxis.set(1, 0, 0);
      else if (axis === 'y') rotationAxis.set(0, 1, 0);
      else if (axis === 'z') rotationAxis.set(0, 0, 1);
      
      quaternion.setFromAxisAngle(rotationAxis, angle);

      // Transfer cubelets to rotation group
      layer.forEach(cubelet => {
        const worldPos = new THREE.Vector3();
        cubelet.getWorldPosition(worldPos);
        
        const worldQuaternion = new THREE.Quaternion();
        cubelet.getWorldQuaternion(worldQuaternion);
        
        cubeGroup.remove(cubelet);
        group.add(cubelet);
        
        scene.attach(cubelet);
        cubelet.position.copy(worldPos);
        cubelet.quaternion.copy(worldQuaternion);
        group.attach(cubelet);
      });

      const duration = 400;
      const start = Date.now();

      function animateRotation() {
        const elapsed = Date.now() - start;
        const progress = Math.min(elapsed / duration, 1);
        
        // Use easing function for smoother animation
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        const currentQuaternion = new THREE.Quaternion();
        currentQuaternion.slerp(quaternion, easeProgress);
        group.quaternion.copy(currentQuaternion);

        if (progress < 1) {
          requestAnimationFrame(animateRotation);
        } else {
          // Rotation complete
          while (group.children.length) {
            const cubelet = group.children[0];
            
            const worldPos = new THREE.Vector3();
            cubelet.getWorldPosition(worldPos);
            
            const worldQuaternion = new THREE.Quaternion();
            cubelet.getWorldQuaternion(worldQuaternion);
            
            group.remove(cubelet);
            scene.attach(cubelet);
            
            cubelet.position.copy(worldPos);
            cubelet.quaternion.copy(worldQuaternion);
            
            cubelet.position.x = Math.round(cubelet.position.x);
            cubelet.position.y = Math.round(cubelet.position.y);
            cubelet.position.z = Math.round(cubelet.position.z);
            
            cubeGroup.attach(cubelet);
          }
          
          scene.remove(group);
          isRotating = false;
          
          // Check win condition after move
          if (checkWinCondition() && gameStarted) {
            handleWin();
          }
        }
      }

      animateRotation();
    }

    // Enhanced win condition check
    function checkWinCondition() {
      const faces = ['U', 'D', 'L', 'R', 'F', 'B'];
      const faceDirections = [
        new THREE.Vector3(0, 1, 0),   // U
        new THREE.Vector3(0, -1, 0),  // D
        new THREE.Vector3(-1, 0, 0),  // L
        new THREE.Vector3(1, 0, 0),   // R
        new THREE.Vector3(0, 0, 1),   // F
        new THREE.Vector3(0, 0, -1)   // B
      ];

      for (let i = 0; i < faces.length; i++) {
        const face = faces[i];
        const direction = faceDirections[i];
        const layer = getFaceLayer(face);
        
        if (layer.length === 0) continue;
        
        let referenceColor = null;
        
        for (const cubelet of layer) {
          const raycaster = new THREE.Raycaster();
          const origin = cubelet.position.clone().sub(direction.clone().multiplyScalar(0.1));
          raycaster.set(origin, direction);
          
          const intersects = raycaster.intersectObject(cubelet);
          if (intersects.length > 0) {
            const faceIndex = intersects[0].faceIndex;
            const materialIndex = Math.floor(faceIndex / 2);
            const color = cubelet.material[materialIndex].color.getHex();
            
            if (referenceColor === null) {
              referenceColor = color;
            } else if (color !== referenceColor) {
              return false;
            }
          }
        }
      }
      
      return true;
    }

    // Enhanced scramble function
    function scramble() {
      resetGame();
      
      const moves = ['U', 'D', 'L', 'R', 'F', 'B'];
      const moveCount = 25;
      let movesMade = 0;
      isRotating = true;

      document.getElementById('btnScramble').classList.add('loading');

      function makeMove() {
        if (movesMade < moveCount) {
          const move = moves[Math.floor(Math.random() * moves.length)];
          
          const layer = getFaceLayer(move);
          const axis = faceAxis[move];
          const direction = faceDirection[move];
          const angle = Math.PI / 2 * direction;

          const group = new THREE.Group();
          scene.add(group);
          
          const quaternion = new THREE.Quaternion();
          const rotationAxis = new THREE.Vector3();
          
          if (axis === 'x') rotationAxis.set(1, 0, 0);
          else if (axis === 'y') rotationAxis.set(0, 1, 0);
          else if (axis === 'z') rotationAxis.set(0, 0, 1);
          
          quaternion.setFromAxisAngle(rotationAxis, angle);

          layer.forEach(cubelet => {
            const worldPos = new THREE.Vector3();
            cubelet.getWorldPosition(worldPos);
            
            const worldQuaternion = new THREE.Quaternion();
            cubelet.getWorldQuaternion(worldQuaternion);
            
            cubeGroup.remove(cubelet);
            group.add(cubelet);
            
            scene.attach(cubelet);
            cubelet.position.copy(worldPos);
            cubelet.quaternion.copy(worldQuaternion);
            group.attach(cubelet);
          });

          const duration = 80;
          const start = Date.now();

          function animateScrambleRotation() {
            const elapsed = Date.now() - start;
            const progress = Math.min(elapsed / duration, 1);
            
            const currentQuaternion = new THREE.Quaternion();
            currentQuaternion.slerp(quaternion, progress);
            group.quaternion.copy(currentQuaternion);

            if (progress < 1) {
              requestAnimationFrame(animateScrambleRotation);
            } else {
              while (group.children.length) {
                const cubelet = group.children[0];
                
                const worldPos = new THREE.Vector3();
                cubelet.getWorldPosition(worldPos);
                
                const worldQuaternion = new THREE.Quaternion();
                cubelet.getWorldQuaternion(worldQuaternion);
                
                group.remove(cubelet);
                scene.attach(cubelet);
                
                cubelet.position.copy(worldPos);
                cubelet.quaternion.copy(worldQuaternion);
                
                cubelet.position.x = Math.round(cubelet.position.x);
                cubelet.position.y = Math.round(cubelet.position.y);
                cubelet.position.z = Math.round(cubelet.position.z);
                
                cubeGroup.attach(cubelet);
              }
              
              scene.remove(group);
              movesMade++;
              
              setTimeout(makeMove, 30);
            }
          }

          animateScrambleRotation();
        } else {
          isRotating = false;
          document.getElementById('btnScramble').classList.remove('loading');
        }
      }

      makeMove();
    }

    function solve() {
      stopTimer();
      resetGame();
      isRotating = true;

      // Animate solve
      const solveAnimation = () => {
        cubeGroup.rotation.x += 0.02;
        cubeGroup.rotation.y += 0.02;
        
        setTimeout(() => {
          // Reset to solved state
          while (cubeGroup.children.length > 0) {
            const cubelet = cubeGroup.children[0];
            cubeGroup.remove(cubelet);
            scene.remove(cubelet);
          }

          cubeGroup.rotation.set(0, 0, 0);
          cubelets.length = 0;

          for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
              for (let z = -1; z <= 1; z++) {
                if (x === 0 && y === 0 && z === 0) continue;
                const cubelet = createCubelet(x, y, z);
                cubeGroup.add(cubelet);
                cubelets.push(cubelet);
              }
            }
          }

          isRotating = false;
        }, 1000);
      };

      solveAnimation();
    }

    // Timer functions
    function startTimer() {
      if (timerInterval) return;
      
      startTime = Date.now() - elapsedTime;
      timerInterval = setInterval(() => {
        elapsedTime = Date.now() - startTime;
        document.getElementById('timer').textContent = `${(elapsedTime / 1000).toFixed(2)}s`;
      }, 10);
    }

    function pauseTimer() {
      clearInterval(timerInterval);
      timerInterval = null;
    }

    function stopTimer() {
      clearInterval(timerInterval);
      timerInterval = null;
      elapsedTime = 0;
      document.getElementById('timer').textContent = "0.00s";
    }

    // Game state management
    function resetGame() {
      setGameState(false);
      isPaused = false;
      stopTimer();
      moveCount = 0;
      updateMoveCounter();
      controls.enabled = true;
      
      const faceButtons = document.querySelectorAll('.face-btn');
      faceButtons.forEach(btn => btn.disabled = false);
    }

    function setGameState(started) {
      gameStarted = started;
      
      const pauseBtn = document.getElementById('btnPause');
      
      if (started) {
        pauseBtn.classList.remove('hidden');
        pauseBtn.textContent = "â¸ï¸ Pause";
        isPaused = false;
      } else {
        pauseBtn.classList.add('hidden');
      }
    }

    function togglePause() {
      if (!gameStarted) return;
      
      isPaused = !isPaused;
      const pauseBtn = document.getElementById('btnPause');
      
      if (isPaused) {
        pauseBtn.textContent = "â–¶ï¸ Resume";
        pauseTimer();
        controls.enabled = false;
        
        const faceButtons = document.querySelectorAll('.face-btn');
        faceButtons.forEach(btn => btn.disabled = true);
        
      } else {
        pauseBtn.textContent = "â¸ï¸ Pause";
        startTimer();
        controls.enabled = true;
        
        const faceButtons = document.querySelectorAll('.face-btn');
        faceButtons.forEach(btn => btn.disabled = false);
      }
    }

    function updateMoveCounter() {
      const counter = document.getElementById('moveCount');
      counter.textContent = moveCount;
      counter.classList.add('move-animation');
      setTimeout(() => counter.classList.remove('move-animation'), 300);
    }

    function handleWin() {
      pauseTimer();
      gamesWon++;
      
      // Update best time
      if (!bestTime || elapsedTime < parseFloat(bestTime)) {
        bestTime = elapsedTime.toString();
        localStorage.setItem('rubiksBestTime', bestTime);
        document.getElementById('bestTime').textContent = `${(elapsedTime / 1000).toFixed(2)}s`;
      }
      
      // Update games won
      localStorage.setItem('rubiksGamesWon', gamesWon.toString());
      document.getElementById('gamesWon').textContent = gamesWon;
      
      // Show win message
      const winMessage = document.getElementById('winMessage');
      const winStats = document.getElementById('winStats');
      winStats.innerHTML = `
        Time: ${(elapsedTime / 1000).toFixed(2)}s<br>
        Moves: ${moveCount}<br>
        ${!bestTime || elapsedTime <= parseFloat(bestTime) ? 'ðŸ† New Best Time!' : ''}
      `;
      
      winMessage.classList.add('show');
      
      setTimeout(() => {
        winMessage.classList.remove('show');
      }, 4000);
    }

    // Instructions toggle
    const toggleButton = document.getElementById('toggleInstructions');
    const instructions = document.getElementById('instructions');
    
    toggleButton.addEventListener('click', () => {
      if (instructions.classList.contains('hidden')) {
        instructions.classList.remove('hidden');
        toggleButton.textContent = 'Hide Instructions';
      } else {
        instructions.classList.add('hidden');
        toggleButton.textContent = 'Show Instructions';
      }
    });

    // Event listeners
    document.getElementById('btnU').addEventListener('click', () => rotateFace('U'));
    document.getElementById('btnD').addEventListener('click', () => rotateFace('D'));
    document.getElementById('btnL').addEventListener('click', () => rotateFace('L'));
    document.getElementById('btnR').addEventListener('click', () => rotateFace('R'));
    document.getElementById('btnF').addEventListener('click', () => rotateFace('F'));
    document.getElementById('btnB').addEventListener('click', () => rotateFace('B'));
    document.getElementById('btnScramble').addEventListener('click', scramble);
    document.getElementById('btnSolve').addEventListener('click', solve);
    document.getElementById('btnReset').addEventListener('click', resetGame);
    document.getElementById('btnPause').addEventListener('click', togglePause);

    // Enhanced keyboard controls
    window.addEventListener('keydown', (event) => {
      if (isPaused || isRotating) return;
      
      switch(event.key.toUpperCase()) {
        case 'U': rotateFace('U'); break;
        case 'D': rotateFace('D'); break;
        case 'L': rotateFace('L'); break;
        case 'R': rotateFace('R'); break;
        case 'F': rotateFace('F'); break;
        case 'B': rotateFace('B'); break;
        case ' ': 
          event.preventDefault();
          togglePause(); 
          break;
        case 'S': scramble(); break;
        case 'ENTER': solve(); break;
      }
    });

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize with scrambled cube
    setTimeout(scramble, 1000);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>